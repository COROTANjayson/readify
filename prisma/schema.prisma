// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id    String @id @unique //matches kinde user id
  email String @unique

  File    File[]
  Message Message[]

  stripeCustomerId       String?           @unique @map(name: "stripe_customer_id")
  stripeSubscriptionId   String?           @unique @map(name: "stripe_subscription_id")
  stripePriceId          String?           @map(name: "stripe_price_id")
  stripeCurrentPeriodEnd DateTime?         @map(name: "stripe_current_period_end")
  documentSummaries      DocumentSummary[]
  presentations          Presentation[]
}

enum UploadStatus {
  PENDING
  PROCESSING
  FAILED
  SUCCESS
}

model File {
  id   String @id @default(cuid())
  name String

  uploadStatus UploadStatus @default(PENDING)

  url String
  key String

  // Per-file usage limits
  chatLimit         Int @default(10) // FREE: 10, PRO: unlimited (999999)
  summarizeLimit    Int @default(2) // FREE: 2, PRO: 5
  insightLimit      Int @default(3) // FREE: 3, PRO: 5
  presentationLimit Int @default(2) // FREE: 2, PRO: 5

  // Current usage counters
  chatCount         Int @default(0)
  summarizeCount    Int @default(0)
  insightCount      Int @default(0)
  presentationCount Int @default(0)

  messages        Message[]
  documentSummary DocumentSummary?
  documentInsight DocumentInsight?
  presentations   Presentation[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft delete - doesn't reset limits on other files

  User   User?   @relation(fields: [userId], references: [id])
  userId String?

  @@index([userId])
  @@index([userId, deletedAt])
}

model Message {
  id   String @id @default(cuid())
  text String @db.Text()

  isUserMessage Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
  File      File?    @relation(fields: [fileId], references: [id])
  fileId    String?
}

model DocumentSummary {
  id      String @id @default(cuid())
  summary String @db.Text()

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User   User?   @relation(fields: [userId], references: [id])
  userId String?
  File   File    @relation(fields: [fileId], references: [id], onDelete: Cascade)
  fileId String  @unique

  @@index([userId])
  @@index([fileId])
}

model DocumentInsight {
  id          String   @id @default(cuid())
  insight     String   @db.Text
  keyFindings String[] @default([])
  actionItems String[] @default([])
  questions   String[] @default([])

  userId String
  fileId String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fileId])
}

// Add this to your existing schema.prisma file

model Presentation {
  id          String   @id @default(cuid())
  fileId      String   @unique // Changed to @unique to enforce one presentation per file
  userId      String
  fileName    String
  slideCount  Int
  content     String   @db.Text // JSON string of presentation structure
  pptxData    String   @db.Text // Base64 encoded PPTX file
  downloadUrl String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}
